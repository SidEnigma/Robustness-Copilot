package org.openscience.cdk.similarity;
 
 import org.openscience.cdk.exception.CDKException;
 import org.openscience.cdk.interfaces.IAtom;
 import org.openscience.cdk.interfaces.IAtomContainer;
 
 import javax.vecmath.Point3d;
 import java.util.Iterator;
 
 /**
  * Fast similarity measure for 3D structures.
  * 
  * This class implements a fast descriptor based 3D similarity measure described by Ballester et al
  * ({@cdk.cite BALL2007}). The approach calculates the distances of each atom to four specific points: the
  * centroid of the molecule, the atom that is closest to the centroid, the atom that is farthest from the
  * centroid and the atom that is farthest from the previous atom. Thus we get 4 sets of distance distributions.
  * The final descriptor set is generated by evaluating the first three moments of each distance distribution.
  * 
  * The similarity between two molecules is then evaluated using the inverse of a normalized
  * Manhattan type metric.
  * 
  * This class allows you to evaluate the 3D similarity between two specified molecules as well as
  * generate the 12 descriptors used to characterize the 3D structure which can then be used for a
  * variety of purposes such as storing in a database.
  *
  * <b>Note</b>: The methods of this class do not perform hydrogen removal. If you want to
  * do the calculations excluding hydrogens, you'll need to do it yourself. Also, if the molecule has
  * disconnected components, you should consider one (usually the largest), otherwise all components
  * are considered in the calculation.
  *
  * @author Rajarshi Guha
  * @cdk.created 2007-03-11
  * @cdk.keyword similarity, 3D, manhattan
  * @cdk.githash
  * @cdk.module fingerprint
  */
 public class DistanceMoment {
 
     private static Point3d getGeometricCenter(IAtomContainer atomContainer) throws CDKException {
         double x = 0;
         double y = 0;
         double z = 0;
 
         for (IAtom atom : atomContainer.atoms()) {
             Point3d p = atom.getPoint3d();
             if (p == null) throw new CDKException("Molecule must have 3D coordinates");
             x += p.x;
             y += p.y;
             z += p.z;
         }
         x /= atomContainer.getAtomCount();
         y /= atomContainer.getAtomCount();
         z /= atomContainer.getAtomCount();
         return new Point3d(x, y, z);
     }
 
     private static float mu1(double[] x) {
         float sum = 0;
         for (double aX : x) {
             sum += aX;
         }
         return sum / x.length;
     }
 
     private static float mu2(double[] x, double mean) {
         float sum = 0;
         for (double aX : x) {
             sum += (aX - mean) * (aX - mean);
         }
         return sum / (x.length - 1);
     }
 
     private static float mu3(double[] x, double mean, double sigma) {
         float sum = 0;
         for (double aX : x) {
             sum += ((aX - mean) / sigma) * ((aX - mean) / sigma) * ((aX - mean) / sigma);
         }
         return sum / x.length;
     }
 
 
/** The method helps in evaluating the 12 descriptors that are used to distinguish the 3D shape of a molecule. */
 public static float[] generateMoments(IAtomContainer atomContainer) throws CDKException{
        Point3d centroid = getGeometricCenter(atomContainer);
        double[] x = new double[atomContainer.getAtomCount()];
        double[] y = new double[atomContainer.getAtomCount()];
        double[] z = new double[atomContainer.getAtomCount()];
        int i = 0;
        for (IAtom atom : atomContainer.atoms()) {
            Point3d p = atom.getPoint3d();
            if (p == null) throw new CDKException("Molecule must have 3D coordinates");
            x[i] = p.x - centroid.x;
            y[i] = p.y - centroid.y;
            z[i] = p.z - centroid.z;
            i++;
        }
        float[] moments = new float[12];
        moments[0] = mu1(x);
        moments[1] = mu1(y);
        moments[2] = mu1(z);
        moments[3] = mu2(x, moments[0]);
        moments[4] = mu2(y, moments[1]);
        moments[5] = mu2(z, moments[2]);
        moments[6] = mu3(x, moments[0], Math.sqrt(moments[3]));
        moments[7] = mu3(y, moments[1], Math.sqrt(moments[4]));
        moments[8] = mu3(z, moments[2], Math.sqrt(moments[5]));
        moments[9] = mu3(x, moments[0], moments[3]);
        moments[10] = mu3(y, moments[1], moments[4]);
        moments[11] = mu3(z, moments[2], moments[5]);
        return moments;     
 }

 

}